<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.515">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>SI Appendix</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="SI_Appendix_files/libs/clipboard/clipboard.min.js"></script>
<script src="SI_Appendix_files/libs/quarto-html/quarto.js"></script>
<script src="SI_Appendix_files/libs/quarto-html/popper.min.js"></script>
<script src="SI_Appendix_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="SI_Appendix_files/libs/quarto-html/anchor.min.js"></script>
<link href="SI_Appendix_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="SI_Appendix_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="SI_Appendix_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="SI_Appendix_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="SI_Appendix_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">SI Appendix</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><strong>SI Appendix</strong></p>
<p><br>
</p>
<p><strong>Dataset 1.</strong> SNP-associated effects and standard errors for green-up estimated using the Gulf genetic subpopulation.</p>
<p><strong>Dataset 2.</strong> SNP-associated effects and standard errors for green-up estimated using the Midwest genetic subpopulation.</p>
<p><strong>Dataset 3.</strong> SNP-associated effects and standard errors for green-up estimated using Both genetic subpopulations.</p>
<p><strong>Dataset 4.</strong> SNP-associated effects and standard errors for flowering estimated using the Gulf genetic subpopulation.</p>
<p><strong>Dataset 5.</strong> SNP-associated effects and standard errors for flowering estimated using the Midwest genetic subpopulation.</p>
<p><strong>Dataset 6.</strong> SNP-associated effects and standard errors for flowering estimated using Both genetic subpopulations.</p>
<p><strong>Dataset 7.</strong> Genes within QTL that have functionally validated roles in flowering in rice.</p>
<p><strong>Dataset 8.</strong> Overlap between quantitative trait loci for flowering measured using an outbred pseudo-F2 mapping population, and significant mash effect estimates (with a log10Bayes Factor &gt; 2, or in the 1% tail of most significant mash results) found using three overlapping diversity panels. Genes within 20kb with a functionally validated role in flowering in rice are&nbsp; indicated.&nbsp;</p>
<p><br>
</p>
<p><strong>Figure S1.</strong> Variance components analysis of genetic (purple), genotype by environment (blue), environmental (green), and residual (yellow) terms in models of green-up time as functions of Julian date or weather, for the four northern common gardens (North), the three Texas common gardens (Texas), and for all eight common gardens (All). Dashed lines indicate the cumulative contribution of G and GxE for flowering as a function of day of the year.&nbsp;<img src="https://lh7-us.googleusercontent.com/SPDH2Y9HThoK0pUZQxFuLPUDrIuXAcG73nUSk2ucYN3_CHXSG-c8G4b7Gq6crgo_1IapiGYFV66w_vhfyvxSIW8kPtTQA_tMeviTFamFdsXIPjIjTcaI0dwa7ZqpKN0P1RonX05vbxitm7vLYoYoZw.png" class="img-fluid"></p>
<p><strong>Figure S2.</strong> Effect patterns exhibited by the major data-driven matrices for (a,d,e,j,m,n) Gulf, (b,f,g,k,o,p) Midwest, and (c,h,i,l,q,r) Both subpopulations from Figure 2. (a-i) Green-up date. (j-r) Flowering date. (a-c,j-l) Single-garden effect representations (eigenvectors) of the DD_tPCA data-derived matrices. The percent variation explained of DD_tPCA by each eigenvector is shown on the y-axis. Common gardens are arranged in latitudinal order along the x-axis. In addition, the first eigenvector corresponds to DD_PCA_1, and second corresponds to DD_PCA_2. (d,f,h,m,o,q) The number of SNPs with significant effects in both conditions that exhibit antagonistic pleiotropy between that pair of conditions. (e,g,i,n,p,r) Same as (d,f,h,m,o,q) except for differential sensitivity. Scales for (d,e), (f,g), (h,i), (m,n), (o,p), and (q,r) are identical and located on the first panel in alphabetical order.<img src="https://lh7-us.googleusercontent.com/JV_8jSfymcCRhEQsEuXD2WzHAkM7bOTpEws9j3_H4SbmaTArViZOZQyWld6aMI-xs8DPYLSZBqpxogUokZwU36l5NMMlJgLy-dY8GFwACkYAntFMqAvq9b1C3BsXnbacDYOF3i4kRqXIW4ISTu2Xzg.png" class="img-fluid"></p>
<p><br>
</p>
<p><br>
<img src="https://lh7-us.googleusercontent.com/h-CoStrONeN2vAZcGvcrGRLg1RRQiAhfNYCT9xn9YF5uwInX02rCepO4NU1bRq1ykboFZcOjr1PeEiZXsXRDJ6v51BAzYPWKQ2wd8YhVg2LJA7IMkL5wvEEa8jOw0UDgrZgVwiYZlHQWSqGxT_2q0g.png" class="img-fluid"></p>
<p><strong>Figure S3.</strong> Comparison of mash SNP effects from a diversity panel and effects from an outbred pseudo-F2 cross. (<strong>a</strong>) QTL mapping for four weather-related functions of flowering, and for green-up date, as indicated by the colors: pink, growing degree days (GDD) from green-up date to flowering date, yellow, day length change on the flowering date, green, day length on flowering date; purple, flowering date; gray, green-up date.Dotted lines indicate permutation-based significance thresholds for each weather-related function. Stars indicate QTL with significant enrichment for SNPs in the 1% mash tail; B, G, and M indicate which subpopulation had enrichment: B -&nbsp; both subpopulations, G - Gulf subpopulation, M -Midwest subpopulation. Rug plots show genomic locations of SNPs in the 1% mash tail for flowering date for each subpopulation. (<strong>b</strong>) Schematic comparison of genotypes used for QTL mapping and genotypes used in mash. (<strong>c</strong>) Number of mash runs enriched for SNPs in the 1% mash tail in the 23 QTL intervals from (<strong>a</strong>) (dotted red line), compared to 1000 sets of 23 random QTL intervals of the same size (histogram).<strong>(d</strong>) SNP effects estimated using mash for SNPs with the highest Bayes factor for the three QTL with the highest LOD scores from (<strong>a</strong>) and enrichment of SNPs in the 1% mash tail. SNP genomic position and genetic subpopulation are indicated above each plot. Common gardens are arranged in latitudinal order. (<strong>e</strong>) QTL effect estimates for 23 non-overlapping and partially overlapping QTLs. Colors indicate which of the four weather-related functions of flowering for which the QTL was mapped. An additional five QTLs completely overlapped the QTL displayed; in this case, the QTL with the highest lod score is shown. Solid vertical lines separate QTLs that are not overlapping. Stars indicate QTL with significant enrichment for SNPs in the 1% mash tail; B, G, and M indicate which subpopulation had enrichment, as in (<strong>b</strong>):B -&nbsp; both subpopulations, G - Gulf subpopulation, M -Midwest subpopulation. Common gardens are arranged in latitudinal order.&nbsp;</p>
<p><strong>Table S1.</strong> Green-up and flowering dates phenotypes linked to environmental cues.</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 19%">
<col style="width: 73%">
</colgroup>
<tbody>
<tr class="odd">
<td>Phenotype</td>
<td>Name</td>
<td>Description</td>
</tr>
<tr class="even">
<td>green-up</td>
<td><p>GDD, <strong>n</strong>d</p>
<p>where '<strong>n</strong>' is in {5, 10, 18}</p></td>
<td>Correlations in cumulative growing degree days for the five, ten, or eighteen days prior to green-up.</td>
</tr>
<tr class="odd">
<td>green-up</td>
<td><p>Temp Ave, <strong>n</strong>d</p>
<p>where '<strong>n</strong>' is in {5, 10, 18}</p></td>
<td>Correlations in average temperature for the five, ten, or eighteen days prior to green-up.</td>
</tr>
<tr class="even">
<td>flowering</td>
<td>50% green-up</td>
<td>Correlations in green-up.</td>
</tr>
<tr class="odd">
<td>flowering</td>
<td>daylength</td>
<td>Correlations in day length on the day of flowering.</td>
</tr>
<tr class="even">
<td>flowering</td>
<td>daylength change (s)</td>
<td>Correlations in the change in daylength (in seconds) on the day of flowering.</td>
</tr>
<tr class="odd">
<td>flowering</td>
<td>GDD, GR to FL</td>
<td>Correlations in cumulative GDD between green-up and flowering.</td>
</tr>
<tr class="even">
<td>flowering</td>
<td><p>Rainfall, <strong>n</strong>d sum</p>
<p>where '<strong>n</strong>' is in {1, 3, 5}</p></td>
<td>Correlations in cumulative rainfall in the one, three, or five days before flowering, or in the days between green-up and flowering.</td>
</tr>
</tbody>
</table>
<p><br>
<br>
</p>
<p><strong>Section S1.</strong> Weather-based environmental cues for green-up and flowering date.</p>
<p><br>
</p>
<pre><code>We scored green-up and flowering by day of the year, then linked these dates to multiple environmental factors (Table S1). We defined flowering as functions of eight variables: \'flowering date\' (day of the year), cumulative growing degree days (GDD) between green-up and flowering dates (\'flowering GDD\'), day length on the flowering date (\'flowering daylength\'), change in daylength relative to the previous day on the day of flowering (\'flowering daylength change\'), and four measures of cumulative rainfall: cumulative rainfall between green-up and flowering, and in the one day, three days, and five days before flowering. Cumulative GDD was calculated as GDD = GRFLmaxTmean−Tbase,0, where Tmean is the daily average temperature, defined as (Tmax+Tmin)/2, Tbase is the base temperature of 12 °C for switchgrass, Tmax is the maximum daily temperature, Tmin is the minimum daily temperature, GR is green-up date, and FL is flowering date (Kiniry et al. 2005; Behrman et al. 2013).&nbsp; On a specific day, if Tmean is less than Tbase, the GDD for that day is 0; if Tmean is bigger than Tbase, the GDD for that day is the difference between Tmean and Tbase. We also defined green-up as functions of seven variables: \'green-up date\' (day of the year), cumulative GDD for the five, ten, or eighteen days prior to green-up, and the average air temperature for the five, ten, or eighteen days prior to green-up.

&nbsp;</code></pre>
<p><strong>Section S2.</strong> Hypothesis-based covariance matrix definitions for mash.</p>
<pre><code>We generated hypothesis-based covariance matrices derived from correlations in environmental cues in the green-up or flowering date windows for the three subpopulations (Table S1). These covariance matrices were derived from the same set of phenotypes as environmental functions of green-up and flowering, and represent the correlations between genotypes for these phenotypes across our common gardens. For the diagonal of these matrices, we used the coefficient of variation in these phenotypes within the subpopulation at that garden. Code used to generate these matrices can be found at&nbsp; [git\@github.com](mailto:git@github.com):Alice-MacQueen/pvdiv-phenology-gxe.git/R/Analysis_v0.6_weather_covariance_Uhyp_greenup.Rmd. We used distinct sets of user-specified, hypothesis-based covariance matrices for green-up and flowering, but the same set of matrices for all genetic subgroups. If a hypothesis-based matrix does not capture a common pattern of SNP effects, mash assigns small mixture proportions onto this matrix using maximum likelihood, giving that covariance matrix a low posterior weight summed across all SNP effects, which ultimately causes little to no change in the mash model. Alternatively, SNPs with high mixture proportions on particular environmental covariance matrices and large Bayes factors, which summarize the overall significance of a non-zero effect, represent small genomic intervals with strong evidence for a phenotypic effect correlated with an environmental driver.</code></pre>
<p><br>
</p>
<p><strong>Section S3.</strong> Narrow-sense heritability&nbsp;</p>
<pre><code>In the diversity panel, we determined narrow-sense heritabilities (h2) for green-up and flowering dates at single gardens using genomic relationship matrices calculated using the van Raden method (VanRaden et al. 2009). Genomic relationship matrices were calculated within each subpopulation (Midwest and Gulf) and for both genetic subpopulations (Both). We used ASReml (VSN International) to specify mixed models of the form:</code></pre>
<p><strong>y</strong> = 1 + Zu + e</p>
<p>Var(u) = Gσu2</p>
<p>Var(e) = Iσe2</p>
<p>in which the vector <strong>y</strong> represents the flowering date or green-up date values for that garden, Z the design matrix for random effects, u the whole genome additive genetic effect, and e the residual. Matrix G is the whole genomic relationship matrix based on all SNPs retained for subpopulation-specific analyses. I is the rank-y identity matrix. Phenotypic variance (σp2) is σu2 + σe2. Narrow-sense heritability is then h2 = (σu2/σp2).</p>
<pre><code>These models were run for each of the eight gardens, and across all gardens by adding an additional environmental effect of site without an interaction term. This resulted in 54 models: 3 sets of populations (the Gulf, Midwest, and Both subpopulations) for 9 garden sets (all eight gardens separately, and all eight gardens together) and two phenotypes (green-up date and flowering date).</code></pre>
<p><br>
</p>
<p><strong>Section S4.</strong> Variance components analysis</p>
<pre><code>In the diversity panel, to evaluate our environmental cues as genetic triggers of flowering, we defined green-up and flowering for individual genotypes as functions of seven and eight environmental cues, respectively, then used variance components analysis to partition variance attributed to genetic effects (G), genotype by environment interactions (GxE), environmental effects (E), and error for these phenology-related traits using linear mixed models. We used mixed models of the form:</code></pre>
<p><strong>y</strong> = 1 + Zuu + Zll + Zulul + e</p>
<p>Var(u) = Gσu2</p>
<p>Var(l) = IσE2</p>
<p>Var(ul) = GσuE2</p>
<p>Var(e) = Iσe2</p>
<p>in which the vector <strong>y</strong> represents the individual plant observations of a given trait and Z the design matrices associating trait observations with random factors. Random factors include u, the whole genome additive genetic (G) effect, l, the effect of each location (E), ul, the GxE effect, and e, the residual. Matrix G is the whole genomic relationship matrix. I are rank-y identity matrices.&nbsp;</p>
<pre><code>These models were run for each phenotype as a function of environmental cues. This resulted in 135 models: three sets of populations (the Gulf, Midwest, and Both subpopulations) for three garden sets (All, North, and Texas gardens) and 15 phenotypes (seven green-up functions, and eight flowering functions).</code></pre>
<p><br>
</p>
<p><strong>Section S5.</strong> Multivariate adaptive shrinkage</p>
<pre><code>To evaluate the prevalence and kinds of covariance patterns of SNP effects across our eight common gardens, we used multivariate adaptive shrinkage (mash) on SNP effect estimates from the diversity panel (Urbut et al. 2019). Mash is a statistical method that allows estimation and comparison of many effects jointly across many different conditions; it improves on previous methods by allowing arbitrary correlations in effect sizes among conditions. To this end, mash allows the user to include hypothesis-based covariance matrices, specifies some \'canonical\' covariance matrices with simple patterns of effects, and also generates \'data-driven\' covariance matrices from patterns of effects in the data. Then, mash assigns mixture proportions for each SNP onto each provided covariance matrix using maximum likelihood. Finally, mash uses Bayes\' theorem to shrink effects for each SNP towards the set of covariance matrices in accordance to their mixture proportions. For example, a SNP affecting flowering may have a high mixture proportion, or weight, on a covariance matrix created from a specific environmental cue. In that case, we can infer that the effect of that SNP on flowering is caused by a response to or interaction with that environmental cue. These user-specified and data-driven covariance matrices are an important advantage mash offers for studying patterns of GxE: the user-specified covariance matrices allow hypothesis testing of specific environmental drivers for each SNP, while the data-driven covariance matrices allow exploration of additional unexplained patterns of covariation.&nbsp;

We first conducted univariate GWAS at each common garden for green-up and flowering date, then analyzed the allelic effects for the top 19K unlinked SNPs per univariate GWAS using mash, as in Lovell et al. (2021). To allow for the possibility that different subpopulations had different strengths of connection between our phenotypes and genotypes (Korte and Farlow 2013), we conducted three sets of genetic analyses: on Gulf and Midwest genotypes separately, and on both subpopulations together (hereafter \'Both\' subpopulations). Only SNPs with ≤ 20% missing data and minor allele frequencies \&gt; 0.05 were used in univariate GWAS, resulting in 8.8 million SNPs retained for the Midwest subpopulation, 10.3 million SNPs retained for the Gulf subpopulation, and 12.3 million SNPs retained for Both subpopulations. Then, we created a set of \'random\' markers to account for correlation in effects using a set of 19K relatively unlinked (r2 \&lt; 0.2) markers. Next, we created a set of \'strong\' markers by selecting 19K SNPs with the largest -log10(p-value) in any condition in the univariate GWAS, out of all markers unlinked at (r2 \&lt; 0.2), which represented the SNP with the strongest effect in the 19K LD blocks with the largest univariate effects. We used the \'pvdiv_standard_run()\' function of the switchgrassGWAS R package (https://github.com/Alice-MacQueen/switchgrassGWAS) to conduct GWAS on genotypes from the Midwest, Gulf, and Both subpopulations, used the \'pvdiv_bigsnp2mashr()\' function to convert univariate GWAS output to the matrices of effects and standard errors needed for mash, then used the \'mash_standard_run()\' function to conduct mash, again specifying distinct sets of hypothesis-based covariance matrices for green-up and flowering, but the same set of matrices for all genetic subgroups.&nbsp;</code></pre>
<p><br>
</p>
<p><strong>Section S6.</strong> Outbred pseudo-F2 mapping population and Quantitative Trait Locus mapping</p>
<pre><code>To confirm candidate genomic regions and patterns of allelic effects found in the diversity panel, we analyzed flowering in an outbred pseudo-F2 cross between four individuals, two Midwest and two Gulf individuals. The formation of this mapping population has been described previously (Milano, Lowry, and Juenger 2016). The parents of this cross were DAC, an early flowering Midwest individual, VS16, a late flowering Midwest individual, AP13, an early flowering Gulf individual, and WBC, a late flowering Gulf individual. We made F1 crosses of the two early flowering genotypes, AP13xDAC, and the two late flowering genotypes, WBCxVS16. We then clonally propagated and planted the four parents, the two F1 genotypes (AP13xDAC, and VS16xWBC), and 801 F2 genotypes at eight field sites in May-July of 2015. To be directly comparable to the diversity panel data, only 2019 phenology data from the pseudo-F2 cross from the same eight common garden sites were used here.&nbsp;

Details on the genetic map construction, map polishing and fine-scale reordering can be accessed on &lt;https://datadryad.org/stash/dataset/doi:10.5061/dryad.ghx3ffbjv&gt;. QTL mapping was conducted with R/qtl2 (Broman et al. 2019). We performed a genome scan with a linear mixed model that accounts for the relationships among individuals and for environmental covariates (i.e., field sites). The full model can be expressed as: phenotype = µ + QTL + E + QTLxE + kinship + e, where µ is the population mean, QTL is the marker genetic effect, E is the environmental effects (here, common garden), QTLxE is the interaction between marker genetic and environmental effects, kinship corresponds to the background polygenic variation, and e is the error term. The genome scan was accomplished with the \'scan1\' function. The statistical significance of the genome scan was established by performing a stratified (i.e., stratifying on common garden) permutation test (n=1000) using \'scan1perm\' function. The estimated QTL effect was obtained using \'scan1coef\' function in R/qtl2.&nbsp;</code></pre>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>